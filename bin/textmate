#!/usr/bin/env ruby

require "fileutils"
require "rubygems"
require "thor"

class TextmateInstaller < Thor
  
  # CHANGED: renamed list to remote. Could there be a better name?
  desc "remote [SEARCH]", "Lists all the matching remote bundles"
  method_options 'verbose' => :boolean, 'source' => :optional
  def remote(limit = "", opts={})
    limit = Regexp.new(".*#{limit}.*", "i")
    
    remote_bundle_locations(opts['source']).each do |name,location|
      puts "\n" << name.to_s << " Remote Bundles\n" << name.to_s.gsub(/./,'-') << '---------------'
      
      results = %x[svn list #{e_sh location[:url]}] if location[:scm]==:svn
      results = github(location[:url], limit) if location[:scm]==:github
      # TODO: List the version number somehow. Maybe the Subversion revision number. But what do you do for Git? The Date?
      puts results.map {|x| x.split(".")[0]}.select {|x| x =~ limit}.join("\n") if results
      
      puts 'git remotes not implemented yet' if location[:scm]==:git
    end
  end
  
  desc "list [SEARCH]", "lists all the bundles installed locally"
  def list(limit = "")
    limit = Regexp.new(".*#{limit}.*", "i")
    
    local_bundle_paths.each do |name,bundles_path|
      puts "\n" << name.to_s << " Bundles\n" << name.to_s.gsub(/./,'-') << '--------'
      puts Dir["#{e_sh bundles_path}/*.tmbundle"].map {|x| x.split("/").last.split(".").first}.
        select {|x| x =~ limit}.join("\n")
    end
  end
  
  desc "install NAME", "install a bundle"
  method_options 'verbose' => :boolean, 'source' => :optional
  def install(bundle_name, opts={})
    # TODO: Add an option to remove all other versions of the same bundle
    FileUtils.mkdir_p install_bundles_path
    print "Checking out #{bundle_name}"
    print " from a remote which matches #{opts['source']}" if opts['source']
    puts  '...'
    
    found     = false
    installed = false
    
    remote_bundle_locations(opts['source']).each do |remote_name,location|
      next unless remote_name.to_s.downcase.include? opts['source'].to_s.downcase if opts['source']
      
      cmd = 'echo "git remotes not implemented yet"' if location[:scm]==:git
      cmd = %[svn co #{e_sh location[:url]}/#{e_sh bundle_name}.tmbundle #{e_sh install_bundles_path}/#{e_sh bundle_name}.tmbundle 2>&1] if location[:scm]==:svn
      puts "Trying to checkout '#{e_sh bundle_name}.tmbundle' from #{remote_name}...", '$ '+cmd if opts['verbose']
      
      res = %x{#{cmd}}
      puts res.gsub(/^/,'    ') if opts['verbose']
      
      installed = res =~ /Checked out revision|Initialized empty Git repository/
      
      break if installed
    end
    
    unless installed
      puts "\nNot Found, perhaps you meant... ?"
      remote bundle_name, opts
      abort 'Not Installed.'
    else
      puts "Installed #{bundle_name}!"
    end
    
    puts "Reloading Bundles..."
    reload
    puts "Done."
  end

  desc "uninstall NAME", "Uninstall a bundle. " + "Moves the bundle `NAME.tmbundle` to the trash from every local bundle path"
  def uninstall(bundle_name)
    puts "Removing bundle..."
    # FIXME: Move deleted bundles to the trash instead of rm_rf-ing them?
    # When moving to the trash, maybe move the bundle into a trash/disabled_bundles subfolder 
    #   named as the bundles_path key. Just in case there are multiple versions of 
    #     the same bundle in multiple bundle paths
    local_bundle_paths.each do |name,bundles_path|
      bundle_path = "#{bundles_path}/#{bundle_name}.tmbundle"
      if File.exist? bundle_path
        %x[osascript -e 'tell application "Finder" to move the POSIX file "#{bundle_path}" to trash']
      end
    end
    puts "Reloading bundles..."
    reload
    puts "Done."
  end
  
  desc "reload", "Tell TextMate to Reload all Bundles from the filesystem. " + 'Textmate bundles are automatically reloaded after `install` or `uninstall` operations.'
  def reload
    %x[osascript -e 'tell app "TextMate" to reload bundles']
  end
  
  private
  def remote_bundle_locations(limit=nil)
    remote_bundle_locations = {
      :'Macromates Trunk'  => {:scm => :svn, :url => 'http://macromates.com/svn/Bundles/trunk/Bundles'},
      :'Macromates Review' => {:scm => :svn, :url => 'http://macromates.com/svn/Bundles/trunk/Review/Bundles'},
      
      # TODO: Add Git support to remote_bundle_locations. Define some sort of standard way of listing git repos, checkout how rubygems does it
      # :'Bunch of Git Bundles' => {:scm => :git, :url => 'git://NotImplemented'},
      
      # TODO: Add GitHub support as a remote_bundle_location
      #   This will require fetching the html of the search page, scanning for urls and converting them to git urls
      :'GitHub' => {:scm => :github, :url => 'http://github.com/search?q=tmbundle'},
    }
    # TODO: Add some way to add more custom remotes
    remote_bundle_locations.reject!{|name,v| not name.to_s.downcase.include? limit.to_s.downcase } if limit
    abort "No remote bundle locations matched #{limit}" unless remote_bundle_locations.length > 0
    
    remote_bundle_locations
  end
  
  def local_bundle_paths
    { :Application       => '/Applications/TextMate.app/Contents/SharedSupport/Bundles',
      :User              => "#{ENV["HOME"]}/Library/Application Support/TextMate/Bundles",
      :System            => '/Library/Application Support/TextMate/Bundles',
      :'User Pristine'   => "#{ENV["HOME"]}/Library/Application Support/TextMate/Pristine Copy/Bundles",
      :'System Pristine' => '/Library/Application Support/TextMate/Pristine Copy/Bundles',
    }
  end
  
  def install_bundles_path
    #TODO: Add some way for the user to configure where they'd prefer to install bundles
    local_bundle_paths[:'User Pristine']
  end
  
  def github(url, search)
    # p %x[curl --silent '#{url}+#{search}'].scan(%r`href="(.*tmbundle/tree)"`)
    res = %x[cat '/Users/taylott/Desktop/textmate stdin fkVBIW.html']
    p res.scan(%r`href="([^"]+tmbundle/tree)".*?class="desc"[^>]*>(.*?)</td`im).map{|r| {r[0].sub('/tree','').sub(/^.*\//,'') => {:desc => r[1], :url => "git://github.com" + r[0].gsub(/\/tree$/,'')}} }
  end
  
  
  # Copied from http://macromates.com/svn/Bundles/trunk/Support/lib/escape.rb
  # escape text to make it useable in a shell script as one “word” (string)
  def e_sh(str)
  	str.to_s.gsub(/(?=[^a-zA-Z0-9_.\/\-\x7F-\xFF\n])/, '\\').gsub(/\n/, "'\n'").sub(/^$/, "''")
  end
  
end

# TODO: create a "monument to personal cleverness" by class-izing everything?
# class TextMateBundle
#   def self.find_local(bundle_name)
#     
#   end
#   
#   def self.find_remote(bundle_name)
#     
#   end
#   attr_reader :name
#   attr_reader :location
#   attr_reader :scm
#   def initialize(name, location, scm)
#     @name     = name
#     @location = location
#     @scm      = scm
#   end
#   
#   def install!
#     
#   end
#   
#   def uninstall!
#     
#   end
#   
#   
#   def installed?
#     # List all the installed versions, and where they're at
#   end
#   
#   # TODO: dirty? method to show if there are any deltas
# end

TextmateInstaller.start
